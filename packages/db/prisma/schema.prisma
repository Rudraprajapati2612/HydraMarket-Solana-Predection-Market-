// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

 
model User{
  id              String              @id @default(uuid())
  email           String              @unique
  username        String              @unique
  password        String
  fullName        String?             @map("full_name")
  depositeMemo    String              @unique @map("deposie_memo")
  isActive        Boolean             @default(true) @map("is_active")
  role            UserRole            @default(USER)
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @default(now()) @map("updated_at")

  ledger          Ledger[]
  deposits        Deposit[]
  withdrawals     Withdrawal[]
  marketCreated   Market[]
  orders            Order[]
  positions         Position[]
  @@index([email])
  @@index([username])
  @@index([depositeMemo])
  @@map("user")
}

enum UserRole {
  USER      // Regular user
  ADMIN     // Can create markets
  SUPERADMIN // Full access
}

model PlatformWallet{
  id             String               @id @default(uuid())
  walletType     WalletType           @map("wallet_type")
  address        String               @unique
  name           String               // hot wallet or cold wallet 
  purpose        String     
  isActive       Boolean              @default(true) @map("is_active")
  createdAt      DateTime             @default(now()) @map("created_at")

  @@index([walletType])
  @@map("platform_wallets")
}

enum WalletType{
  HOT
  COLD
}

// User Balanc Per asset
model Ledger{
  userId        String          @map("user_id")
  asset         String
  available     Decimal        @default(0) @db.Decimal(20, 8)
  reserved      Decimal        @default(0) @db.Decimal(20, 8)

  createdAt     DateTime       @default(now()) @map("created_at")
  updatedAt     DateTime       @default(now()) @map("updated_at")

   user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@id([userId, asset])
    @@index([userId])
    @@map("ledger")
}

model LedgerChange {
  id              String         @id @default(uuid())
  userId          String         @map("user_id")
  asset           String
  changeType      ChangeType     @map("change_type")
  amount          Decimal        @db.Decimal(20, 8)
  balanceBefore   Decimal        @map("balance_before") @db.Decimal(20, 8)
  balanceAfter    Decimal        @map("balance_after") @db.Decimal(20, 8)
  referenceId     String?        @map("reference_id") // tx_hash for deposits
  referenceType   String?        @map("reference_type") // "DEPOSIT", "WITHDRAWAL", etc.
  metadata        String?        @db.Text // JSON string for additional data
  createdAt       DateTime       @default(now()) @map("created_at")
  
  @@index([userId, createdAt(sort: Desc)])
  @@index([referenceId])
  @@map("ledger_changes")
}

enum ChangeType{
  DEPOSIT
  WITHDRAWAL
  RESERVE
  RELEASE
  TRADE_BUY
  TRADE_SELL
}


model Deposit{
  id              String          @id @default(uuid())
  userId          String          @map("user_id")
  asset           String
  amount          Decimal         @db.Decimal(20,8)
  txHash          String          @unique @map("tx_hash")
  memo            String?
  fromAddress     String?          @map("from_address")
  toAddress       String          @map("to_address")
  status          DepositStatus  @default(PENDING)
  blockTime       DateTime?         @map("block_time")
  confirmedAt     DateTime?      @map("confirmed_at")
  createdAt       DateTime        @default(now()) @map("created_at")


  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, createdAt(sort: Desc)])
  @@index([txHash])
  @@index([status])
  @@index([memo])
  @@map("deposits")
}

enum DepositStatus{
  PENDING
  CONFIRMED
  FAILED 
}


model Withdrawal{
  id              String          @id   @default(uuid())
  userId          String          @map("user_id")
  asset           String
  amount          Decimal         @db.Decimal(20,8)
  destinationAddress String       @map("destination_address")
  txHash          String?         @unique @map("tx_hash")
  status          WithdrawalStatus    @default(PENDING)
  requestedAt     DateTime        @default(now())  @map("requested_at")
  processedAt     DateTime?        @map("processed_at")
  failureReason   String?         @map("failure_reason")

  user            User            @relation(fields: [userId],references: [id],onDelete: Cascade)

  @@index([userId, requestedAt(sort: Desc)])
  @@index([status])
  @@map("withdrawals")
}

enum WithdrawalStatus {
  PENDING
  PROCESSING
  CONFIRMED
  FAILED
}


model Market{
  id                String         @id @default(uuid())
  marketId          String         @unique @map("market_id")
  question          String  
  description       String
  category          String
  creatorId         String         @map("creator_id")
  creator           User           @relation(fields: [creatorId],references: [id])

  marketPda         String        @map("market_pda")
  escrowVaultPda    String        @map("escrow_vault_pda")
  yesTokenMint      String        @map("yes_token_mint")
  noTokenMint       String        @map("no_token_mint")

  state             MarketState   @default(CLOSE)
  outcome           MarketOutcome?

  createdAt         DateTime          @default(now()) @map("created_at")
  expiresAt         DateTime          @map("expires_at")
  resolvedAt        DateTime?         @map("resolved_at")
  
  orders            Order[]
  positions         Position[]
  @@map("markets")
}

enum MarketState{
  OPEN
  CLOSE
  CREATED
  RESOLVED
  RESOLVING
  PAUSED
}

enum MarketOutcome {
  YES
  NO
  INVALID
}


model Order{
  id                  String                      @id @default(uuid())
  userId              String                      @map("user_id")
  user                User                        @relation(fields: [userId],references: [id])
  marketId            String                      @map("market_id")
  market              Market                      @relation(fields: [marketId],references: [id])

  side              OrderSide         // BUY_YES, BUY_NO, SELL_YES, SELL_NO
  outcome           OrderOutcome
  amount            Decimal           @db.Decimal(20, 6) // USDC amount
  price             Decimal           @db.Decimal(5, 4)  // 0.0000 - 1.0000
  quantity          Decimal           @db.Decimal(20, 6) // Token quantity
  
  status            OrderStatus       @default(PENDING)
  filledQuantity    Decimal           @default(0) @map("filled_quantity") @db.Decimal(20, 6)
  
  createdAt         DateTime          @default(now()) @map("created_at")
  updatedAt         DateTime          @updatedAt @map("updated_at")
  
  @@index([userId])
  @@index([marketId])
  @@index([status])
  @@map("orders")

}

enum OrderOutcome{
  NO
  YES
}
enum OrderSide {
  BUY
  SELL
}

enum OrderStatus {
  PENDING
  PARTIAL
  FILLED
  CANCELLED
  FAILED
  MATCHED
  OPEN
}

model Position{
  id                 String             @id @default(uuid())
  userId             String             @map("user_id")
  user               User               @relation(fields: [userId],references: [id])
  marketId           String             @map("market_id")
  market             Market             @relation(fields: [marketId],references: [id])
  
  yesTokens         Decimal             @default(0) @map("yes_tokens") @db.Decimal(20, 6)
  noTokens          Decimal             @default(0) @map("no_tokens") @db.Decimal(20, 6)
  avgYesPrice       Decimal?            @map("avg_yes_price") @db.Decimal(5, 4)
  avgNoPrice        Decimal?            @map("avg_no_price") @db.Decimal(5, 4)


  yesTokenAccount   String?             @map("yes_token_account")
  noTokenAccount    String?             @map("no_token_account")

  isClaimed         Boolean             @default(false) @map("is_claimed")
  claimedAt         DateTime?           @map("claimed_at")
  claimTxHash       String?             @map("claim_tx_hash")

  createdAt         DateTime           @default(now()) @map("created_at")
  updatedAt         DateTime           @updatedAt @map("updated_at")
  
  @@unique([userId, marketId])
  @@index([userId])
  @@index([marketId])
  @@map("positions")
}

model MintTransaction {
  id                String                @id @default(uuid())
  marketId          String                @map("user_id")
  yesRecipientId    String                @map("yes_recipient_id")
  noRecipientId     String                @map("no_recipient_id")
  pairs             Int
  collateralAmount  Decimal               @map("collateral_amount") @db.Decimal(20,6)
  txHash            String                @unique  @map("tx_hash")
  status            TransactionStatus     @default(PENDING)

  createdAt         DateTime          @default(now()) @map("created_at")
  confirmedAt       DateTime?         @map("confirmed_at")
  
  @@index([marketId])
  @@index([status])
  @@map("mint_transactions")
}

enum TransactionStatus {
  PENDING
  PROCESSING
  CONFIRMED
  FAILED
}


model Trade{
  id                 String                @id @default(uuid())
  marketId           String                @map("market_id")
  outcome            String
  buyerId            String                @map("buyer_id")
  sellerId           String                @map("seller_id")
  quantity           Decimal               @db.Decimal(20, 6)
  price              Decimal               @db.Decimal(5, 4)
  tradeType          TradeType             @map("trade_type")
  createdAt          DateTime              @default(now()) @map("created_at")
  
  @@index([marketId])
  @@index([buyerId])
  @@index([sellerId])
  @@map("trades")

}


enum TradeType{
  SECONDARY
  COMPLEMENTARY
}